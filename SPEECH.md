# Текст доклада: Вайб-кодинг в системе 1С Предприятие

**Время доклада:** ~20 минут  
**Количество слайдов:** 14

---

## Слайд 1: Титульный

Добрый день! Тема моего доклада — «Вайб-кодинг в системе 1С Предприятие». Мы поговорим о новой парадигме программирования с использованием искусственного интеллекта и о том, как она применяется в экосистеме 1С.

---

## Слайд 2: Что такое вайб-кодинг?

Термин «вайб-кодинг» ввёл Андрей Карпати — сооснователь OpenAI и бывший директор по искусственному интеллекту в Tesla. Второго февраля 2025 года он написал в социальной сети X:

*«Появился новый вид программирования, который я называю вайб-кодинг. Вы полностью отдаётесь вайбу, принимаете экспоненциальный рост и забываете, что код вообще существует».*

Карпати описал свой опыт работы с IDE Cursor и моделью Claude: он разговаривал с AI голосом, нажимал «Accept All» не читая код, а ошибки просто копировал обратно в чат. Код рос за пределами его понимания, но приложения работали.

Собственно, описанный опыт Карпати составляет суть процесса: мы формулируем агенту задание, он создаёт по нему код, затем проверяет его, вносит исправления — и так до тех пор, пока не будет достигнут нужный результат.

Важно отметить, что сам Карпати признал — этот подход годится для прототипов и личных проектов, а не для продакшн-систем.

В ноябре 2025 года Collins Dictionary назвал «vibe coding» словом года.

Если немного поразмыслить над этой формулировкой, становятся очевидны несколько важных аспектов:

**Первое** — насколько чёткий критерий приёмки должна содержать формулировка задачи? Как понять, что задача решена? Каким образом агент должен понять, что работа завершилась успехом?

**Второе** — для проверки кода агенту нужен помощник. В самом простом случае это человек, который запускает компилятор и выполнение программы, а затем передаёт агенту результат. В более сложном варианте это может делать инструментарий под управлением самого агента — те самые MCP-серверы, о которых мы поговорим позже.

**Третье** — напрашиваются критерии качества кода. Нужны правила, чтобы код не разрастался до бесконечности, чтобы его когнитивная сложность не зашкаливала. Чем легче человеку будет разобраться в написанном — тем лучше.

---

## Слайд 3: Вайб-кодинг vs AI-ассистирование

Эти размышления наводят на мысль, что важно разграничить вайб-кодинг и использование AI-помощников для разработки ПО. Разработчик Саймон Уиллисон чётко сформулировал границу: если нейросеть написала каждую строку, но вы всё проверили, протестировали и поняли — это не вайб-кодинг, это использование LLM как помощника при наборе текста.

Посмотрим на таблицу различий:

При вайб-кодинге ревью кода отсутствует — мы просто нажимаем «Accept All». Понимание результата не требуется. Ошибки исправляем копипастом обратно в AI. Применяется для прототипов и личных проектов.

При AI-ассистировании ревью кода обязательный. Мы полностью понимаем результат. Ошибки анализируем вручную. Такой подход применим для продакшн-систем.

Итак, становится понятно, что вайб-кодинг выделяют как отдельную парадигму именно с таким отличительным признаком: программист не смотрит в код. Тогда закономерно ожидать, что становится исключительно важен процесс автовалидации

---

## Слайд 4: Цикл работы AI-агента

Теперь поговорим о том, как работают AI-агенты. Основной цикл их работы напоминает CI/CD пайплайн и состоит из четырёх этапов:

Первый — **планирование**: агент определяет последовательность действий и задач.

Второй — **выполнение**: реализация запланированных действий.

Третий — **наблюдение**: оценка результатов своей работы.

Четвёртый — **обучение**: понимание, насколько выполненные шаги помогли достичь цели.

Что характеризует полноценного AI-агента? Автономность работы, использование внешних инструментов, коллаборация с другими агентами, обучаемость и рефлексия.

Это итеративный процесс — агент постепенно приближается к цели, как в пайплайнах сборки и деплоя.

---

## Слайд 5: 1С:Напарник — официальный инструмент

Фирма 1С представила собственное решение — 1С:Напарник, доступный по адресу code.1c.ai. Это плагин для среды разработки 1С:EDT версии 2023.3.6 и выше.

Какие у него возможности? Автоматическое продолжение кода, генерация по описанию на естественном языке, создание документирующих комментариев, поиск и исправление ошибок с объяснениями.

Критически важная особенность — понимание контекста конфигурации. На самом деле, с этим проблема.
В той редакции, с которой я работал, этого не было. Возможно, это (как нередко бывает в мире 1С) - не совсем то, 
о чем мы подумали. То есть фирма 1С что-то под этим подразумевает, но не то, что понимаем под этим мы.

Для использования требуется учётная запись 1С:ИТС. Подписчики ИТС могут использовать его бесплатно до октября 2026 года.

1С:Напарник пока не является полноценным AI-агентом. У него минимальная автономность, нет поддержки MCP и A2A протоколов, ограниченная обучаемость.

---

## Слайд 6: MCP — «Type-C для нейросетей»

Ключевой технологией 2025 года для вайб-кодинга в 1С стали MCP-серверы. MCP — это Model Context Protocol, который называют «Type-C для нейросетей». Это протокол подключения внешних инструментов к AI-агентам.

MCP состоит из трёх компонентов:

**Инструкции** — это промпты, описание того, как должна работать нейросеть, в каком формате выдавать данные.

**Ресурсы** — контекстная информация, с которой работает агент.

**Утилиты** или tools — через них происходит взаимодействие с внешним миром.

Для 1С уже существуют готовые MCP-серверы от сообщества Infostart: 1c-metadata для поиска по метаданным, 1c-help для справки синтакс-помощника, mcp-bsl-checker для проверки синтаксиса. Перечисленные MCP-серверы являются RAG-системами,
предназначение которых добавлять необходимую информацию в рамках контекстного окна языковой модели, подключенной к агенту.
Почему это важно для вайб-кодинга в 1С? Потому что современные модели "плохо знают" систему 1С Предпрятие и ее встроенный язык. В отличие, от С++ и Python, модели пишут не очень релевантный код, если не снабжать их дополнительным контекстом.

Рекомендуемый стек: IDE Cursor за 20 долларов в месяц в связке с Gemini 2.5 Pro или Claude, плюс 1С:EDT для отладки форм.

---

## Слайд 7: Лучшие нейросети для 1С-кода

Перейдём к сравнению нейросетей. По данным финального бенчмарка от ноября 2025 года с сайта vibecoding1c.ru:

На первом месте — **Claude Opus 4.5**. Это новый лидер, который справляется даже с запросами с транзитивным замыканием для неограниченной иерархии.

На втором месте — **Gemini 2.5 Pro**. Близко к лидеру, при этом работает быстрее и стоит дешевле.

Третье место — **Claude Sonnet 4.5**. Хороший баланс цены и качества.

Четвёртое место — **Qwen3-Coder**. Лучшая среди открытых моделей.

А вот GPT-5 и Codex, к сожалению, не оправдали надежд для работы с 1С. Модели OpenAI плохо работают с 1С без MCP-серверов.

Примечание.
Транзитивное замыкание — это алгоритм обхода иерархии с неограниченным числом уровней вложенности.
В контексте 1С типичный пример — справочник «Номенклатура» или «Подразделения» с иерархией групп. Задача: получить все элементы, включая вложенные на любую глубину.
Проблема: в языке запросов 1С нет рекурсивных CTE (как WITH RECURSIVE в SQL). Поэтому для обхода неограниченной иерархии нужно использовать специальную конструкцию — временную таблицу с итерациями, которая «разматывает» иерархию уровень за уровнем.

---

## Слайд 8: Практические сценарии применения

Что уже работает прямо сейчас?

Генерация шаблонного кода — обработки, печатные формы, регламентные задания. Написание запросов на языке запросов 1С. Автодокументирование модулей. Рефакторинг и оптимизация. Сборка и деплой через CLI с помощью Vanessa. BDD-тестирование. REST и OData интеграции.

Чего пока стоит подождать?

Сложные динамические формы — нейросети их почти не понимают. A2A-оркестрация без участия человека. Автогенерация длинных модулей с нуля. Работа со сложными иерархическими запросами.

По данным с конференции по вайбкодингу, рост производительности составляет от 30 до 400 процентов.

Следует отметить, что особенную важность в проектах с использованием AI-агента играет формулировка задачи.
То есть чем сильнее возможно сузить контекст выполения, тем лучше получается результат. 
Таким образом, мы приходим к тому, что основной упор программист должен сделать на декомпозиции
задачи и формулировки детального ТЗ. Неожиданно, ЛЛМ в режиме чат-бота спопобна повысить
производительность при составлении ТЗ - то, что раньше занимало от одного до пяти рабочих дней,
теперь формируется за четыре часа.

---

## Слайд 9: Пример — галлюцинации vs реальность

Рассмотрим конкретный пример проблемы, с которой сталкиваются разработчики.

Без базы знаний нейросеть может «выдумать» несуществующий метод. Например, она пишет: «Число равно СлучайноеЧисло от 1 до 10». Такого метода глобального контекста не существует! При этом линтер не находит ошибку, потому что такой вызов теоретически может существовать в каком-то общем модуле.

А вот с подключённой базой знаний через MCP нейросеть находит в документации правильный объект и пишет корректный код: создаёт объект ГенераторСлучайныхЧисел и уже у него вызывает метод СлучайноеЧисло.

Вывод: MCP-серверы с базой знаний — синтакс-помощником, документацией ИТС — компенсируют нехватку знаний нейросетей о языке 1С.

Да, документация ИТС является хорошим подспорьем - там есть примеры кода. 
Правда, она ограничена по доступности, но это легко решаемо. Если делать для себя и не распространять, то даже 
не накажут.

---

## Слайд 10: Структура эффективного промпта

Как правильно формулировать запросы к AI? Вот пример эффективного промпта:

*«Ты опытный разработчик 1С с опытом более 10 лет. Напиши код загрузки Excel-файла через COM-объект. Файл содержит колонки: Артикул, Наименование, Цена. Данные нужно загрузить в справочник Номенклатура. Требования: платформа 8.3.24, использовать транзакцию, обработать ошибки, добавить комментарии. Код должен работать на сервере.»*

Формула эффективного промпта: **Роль** плюс **Цель** плюс **Контекст** плюс **Требования** плюс **Формат**.

Чем конкретнее вы опишете задачу, тем качественнее будет результат.
И логи. Указывайте в промптах, что нужно писать логи. Логи удобно возвращать назад, агенту для валидации кода.

---

## Слайд 11: Ограничения и риски

Теперь о проблемах. Технические ограничения:

Кириллица в коде — нейросети обучены преимущественно на англоязычных данных. Галлюцинации — модели выдумывают несуществующие методы. Смешение версий 7.7 и 8.x — путаница в синтаксисе. Малый объём обучающих данных — код 1С скудно представлен на GitHub, документация ИТС закрыта от индексации.

Вопросы безопасности:

Утечка кода во внешние LLM — вы передаёте конфиденциальный код на внешние серверы. Лицензионные вопросы — БСП распространяется под CC BY 4.0. Конфиденциальные данные клиентов.

Какие есть решения? Локальные модели через LM Studio или Ollama. Обфускация данных перед отправкой. Использование RAG вместо прямой передачи контекста.

---

## Слайд 12: Перспективы развития

По прогнозу Кевина Скотта, технического директора Microsoft, к 2030 году 95 процентов кода будет генерироваться искусственным интеллектом.

Какие тренды мы видим? Развитие MCP-экосистемы как ключевого звена адаптации 1С к эпохе AI-кодинга. Появление специализированных AI-агентов с возможностью автономной сборки, деплоя и тестирования. Интеграция 1С:Напарника в полноценный продакшн-инструмент. A2A взаимодействие между агентами.

Рекомендация от экспертов фирмы 1С — модель 60 на 40: использовать AI для генерации 60 процентов базового кода, а 40 процентов времени тратить на доработку и тестирование.

На первой специализированной конференции по вайбкодингу в 1С в октябре 2025 года прозвучал тезис: «Рынок 1С уже никогда не будет прежним».

---

## Слайд 13: Выводы

Главный вывод моего доклада:

**AI не заменит 1С-разработчика, но разработчик с AI заменит разработчика без AI.**

Вайб-кодинг в экосистеме 1С — это уже не футуристическая концепция, а рабочий инструмент с измеримым эффектом и конкретными ограничениями.

Критическая оговорка: генерируемый код требует обязательной проверки. Для продакшн-систем вайб-кодинг в чистом виде неприменим.

С чего начать уже сегодня? Попробуйте 1С:Напарник на code.1c.ai. Изучите материалы на vibecoding1c.ru. Установите Cursor и поэкспериментируйте.

Спасибо за внимание!

---

## Слайд 14: Источники

На последнем слайде представлены источники, которые я использовал при подготовке доклада. Все ссылки доступны в материалах презентации.

Презентация опубликована по адресу gammabox2020.github.io/vibe-coding-1c — вы можете её посмотреть и скачать.

Готов ответить на ваши вопросы.

---

## Возможные вопросы и ответы

**В: Можно ли использовать вайб-кодинг для серьёзных проектов?**
О: В чистом виде — нет. Но AI-ассистирование с обязательным код-ревью уже активно применяется в продакшне. Модель 60/40 — разумный компромисс.

**В: Какую нейросеть выбрать для начала?**
О: Для экспериментов — Claude Sonnet через Cursor. Для серьёзной работы — Claude Opus 4.5 или Gemini 2.5 Pro с подключёнными MCP-серверами.

**В: Насколько безопасно передавать код во внешние LLM?**
О: Риски есть. Для работы с конфиденциальным кодом рекомендую локальные модели через Ollama или LM Studio. Также помогает обфускация чувствительных данных.

**В: Заменит ли AI программистов 1С?**
О: Не заменит, но изменит профессию. Разработчик будет больше управлять AI-агентами, проектировать архитектуру и проверять результаты. Рутинный код будет генерироваться автоматически.
